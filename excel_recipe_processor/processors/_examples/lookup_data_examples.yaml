# excel_recipe_processor/processors/_examples/lookup_data_examples.yaml
# Clean lookup processor examples - stage-to-stage workflow only

description: "Clean stage-to-stage lookup operations with smart key normalization and simple configuration"

basic_example:
  description: "Simple customer lookup from stage data"
  yaml: |
    # Basic lookup workflow: import data -> lookup -> result
    
    settings:
      description: "Add customer details to order data"
      stages:
        - stage_name: "raw_orders"
          description: "Imported order data"
          protected: false
        - stage_name: "customer_data" 
          description: "Customer reference data"
          protected: false
        - stage_name: "enriched_orders"
          description: "Orders with customer details"
          protected: false
    
    recipe:
      # Step 1: Import order data
      - step_description: "Import order transactions"
        processor_type: "import_file"
        input_file: "orders.xlsx"
        save_to_stage: "raw_orders"
      
      # Step 2: Import customer reference data
      - step_description: "Import customer master data"
        processor_type: "import_file"
        input_file: "customers.xlsx"
        save_to_stage: "customer_data"
      
      # Step 3: Lookup customer details
      - step_description: "Add customer details to orders"
        processor_type: "lookup_data"
        source_stage: "raw_orders"
        save_to_stage: "enriched_orders"
        # REQ - Stage containing lookup data
        lookup_stage: "customer_data"
        # REQ - Key column in lookup data
        match_col_in_lookup_data: "Customer_ID"
        # REQ - Key column in main data  
        match_col_in_main_data: "Customer_ID"
        # REQ - Columns to bring from lookup data
        lookup_columns: ["Customer_Name", "Region", "Tier"]

key_normalization_example:
  description: "Handle type mismatches and format issues automatically"
  yaml: |
    # Demonstrates smart key normalization for common data issues
    
    settings:
      description: "Handle mixed data types in lookup keys"
      stages:
        - stage_name: "sales_data"
          description: "Sales with mixed ID formats"
          protected: false
        - stage_name: "product_catalog"
          description: "Product reference with clean IDs"
          protected: false
        - stage_name: "normalized_sales"
          description: "Sales with product details"
          protected: false
    
    recipe:
      - step_description: "Import sales data (IDs may be: 1001, '1002.0', ' 1003 ')"
        processor_type: "import_file"
        input_file: "sales_data.xlsx"
        save_to_stage: "sales_data"
      
      - step_description: "Import product catalog (clean string IDs: '1001', '1002')"
        processor_type: "import_file"
        input_file: "product_catalog.xlsx"
        save_to_stage: "product_catalog"
      
      - step_description: "Lookup with automatic key normalization"
        processor_type: "lookup_data"
        source_stage: "sales_data"
        save_to_stage: "normalized_sales"
        lookup_stage: "product_catalog"
        match_col_in_lookup_data: "Product_ID"
        match_col_in_main_data: "Product_ID"
        lookup_columns: ["Product_Name", "Category", "Unit_Price"]
        # OPT - Enable smart normalization (default: true)
        # Handles: numeric vs string, trailing .0, whitespace, null values
        normalize_keys: true

column_naming_example:
  description: "Use prefix/suffix to avoid column name conflicts"
  yaml: |
    # Handle situations where lookup columns conflict with existing columns
    
    settings:
      description: "Add product and customer status without conflicts"
      stages:
        - stage_name: "order_data"
          description: "Orders with existing Status column"
          protected: false
        - stage_name: "customer_lookup"
          description: "Customer data with Status column"
          protected: false
        - stage_name: "product_lookup"
          description: "Product data with Status column"
          protected: false
        - stage_name: "fully_enriched"
          description: "Orders with all details"
          protected: false
    
    recipe:
      # Multiple lookups with different prefixes to avoid conflicts
      - step_description: "Add customer details with prefix"
        processor_type: "lookup_data"
        source_stage: "order_data"
        save_to_stage: "customer_enriched"
        lookup_stage: "customer_lookup"
        match_col_in_lookup_data: "Customer_ID"
        match_col_in_main_data: "Customer_ID"
        lookup_columns: ["Name", "Status", "Region"]
        # OPT - Add prefix to avoid conflicts with existing Status column
        prefix: "Customer_"
        # Result: Customer_Name, Customer_Status, Customer_Region
      
      - step_description: "Add product details with prefix"
        processor_type: "lookup_data"
        source_stage: "customer_enriched"
        save_to_stage: "fully_enriched"
        lookup_stage: "product_lookup"
        match_col_in_lookup_data: "Product_SKU"
        match_col_in_main_data: "Product_SKU"
        lookup_columns: ["Name", "Status", "Category"]
        prefix: "Product_"
        # Result: Product_Name, Product_Status, Product_Category

default_values_example:
  description: "Provide defaults for missing lookup matches"
  yaml: |
    # Handle missing matches with sensible defaults
    
    settings:
      description: "Lookup with fallback values for missing data"
      stages:
        - stage_name: "transaction_data"
          description: "All transactions including unknown customers"
          protected: false
        - stage_name: "known_customers"
          description: "Partial customer database"
          protected: false  
        - stage_name: "complete_transactions"
          description: "Transactions with customer info or defaults"
          protected: false
    
    recipe:
      - step_description: "Lookup customer details with defaults for unknowns"
        processor_type: "lookup_data"
        source_stage: "transaction_data"
        save_to_stage: "complete_transactions"
        lookup_stage: "known_customers"
        match_col_in_lookup_data: "Customer_ID"
        match_col_in_main_data: "Customer_ID" 
        lookup_columns: ["Customer_Name", "Region", "Tier", "Credit_Limit"]
        # OPT - Provide defaults for missing matches
        default_values:
          Customer_Name: "Unknown Customer"
          Region: "Unassigned"
          Tier: "Standard"
          Credit_Limit: 1000.0

duplicate_handling_example:
  description: "Control how duplicate lookup keys are handled"
  yaml: |
    # Handle duplicate keys in lookup data
    
    settings:
      description: "Lookup with duplicate key resolution"
      stages:
        - stage_name: "order_data"
          description: "Orders to enrich"
          protected: false
        - stage_name: "price_history"
          description: "Product prices with historical entries"
          protected: false
        - stage_name: "current_orders"
          description: "Orders with current prices"
          protected: false
    
    recipe:
      - step_description: "Get current prices (use most recent for duplicates)"
        processor_type: "lookup_data"
        source_stage: "order_data"
        save_to_stage: "current_orders"
        lookup_stage: "price_history"
        match_col_in_lookup_data: "Product_SKU"
        match_col_in_main_data: "Product_SKU"
        lookup_columns: ["Current_Price", "Effective_Date"]
        # OPT - Handle duplicate Product_SKU entries
        # Valid values: "first", "last", "error"
        # Default: "first"
        handle_duplicates: "last"  # Use most recent price

advanced_workflow_example:
  description: "Multi-stage lookup workflow with different join types"
  yaml: |
    # Complex workflow with multiple lookups and join strategies
    
    settings:
      description: "Multi-stage enrichment with validation"
      stages:
        - stage_name: "raw_sales"
          description: "Raw sales data"
          protected: false
        - stage_name: "valid_customers"
          description: "Validated customer list"
          protected: false
        - stage_name: "product_catalog"
          description: "Current product catalog"
          protected: false
        - stage_name: "validated_sales"
          description: "Sales with valid customers only"
          protected: false
        - stage_name: "complete_sales"
          description: "Validated sales with product details"
          protected: false
    
    recipe:
      # Step 1: Validate customers (inner join - only keep valid customers)
      - step_description: "Filter for valid customers only"
        processor_type: "lookup_data"
        source_stage: "raw_sales"
        save_to_stage: "validated_sales"
        lookup_stage: "valid_customers"
        match_col_in_lookup_data: "Customer_ID"
        match_col_in_main_data: "Customer_ID"
        lookup_columns: ["Customer_Name", "Account_Status"]
        # REQ - Inner join removes rows with invalid customers
        join_type: "inner"
      
      # Step 2: Add product details (left join - keep all validated sales)
      - step_description: "Add product information"
        processor_type: "lookup_data"
        source_stage: "validated_sales"
        save_to_stage: "complete_sales"
        lookup_stage: "product_catalog"
        match_col_in_lookup_data: "Product_SKU"
        match_col_in_main_data: "Product_SKU"
        lookup_columns: ["Product_Name", "Category", "Unit_Cost"]
        join_type: "left"
        default_values:
          Product_Name: "Unknown Product"
          Category: "Uncategorized"

parameter_details:
  lookup_stage:
    type: string
    required: true
    description: "Name of stage containing lookup data (must be declared in settings.stages)"
    examples: ["customer_data", "product_catalog", "reference_tables"]
  
  match_col_in_lookup_data:
    type: string
    required: true
    description: "Column name in lookup data to match against"
    examples: ["Customer_ID", "Product_SKU", "Country_Code"]
  
  match_col_in_main_data:
    type: string
    required: true
    description: "Column name in main data to match with match_col_in_lookup_data"
    examples: ["Customer_ID", "SKU", "Country"]
  
  lookup_columns:
    type: list
    required: true
    description: "List of column names to retrieve from lookup data"
    examples: [["Customer_Name", "Region"], ["Product_Name", "Price", "Category"]]
  
  join_type:
    type: string
    required: false
    default: "left"
    description: "Type of join operation"
    valid_values: ["left", "right", "inner", "outer"]
    details:
      left: "Keep all main data rows, add lookup data where available"
      inner: "Only keep rows that have matches in both datasets"
      outer: "Keep all rows from both datasets"
      right: "Keep all lookup data rows, add main data where available"
  
  prefix:
    type: string
    required: false
    default: ""
    description: "Prefix to add to lookup column names to avoid conflicts"
    examples: ["Customer_", "Product_", "Ref_"]
  
  suffix:
    type: string
    required: false
    default: ""
    description: "Suffix to add to lookup column names to avoid conflicts"
    examples: ["_Lookup", "_Ref", "_Data"]
  
  default_values:
    type: dict
    required: false
    description: "Default values for lookup columns when no match is found"
    examples: [{"Customer_Name": "Unknown", "Region": "Unassigned"}]
  
  normalize_keys:
    type: boolean
    required: false
    default: true
    description: "Enable automatic key normalization to handle format mismatches"
    details: "Handles numeric vs string, trailing .0, whitespace, null values"
  
  handle_duplicates:
    type: string
    required: false
    default: "first"
    description: "How to handle duplicate keys in lookup data"
    valid_values: ["first", "last", "error"]
    details:
      first: "Use first occurrence of duplicate key"
      last: "Use last occurrence of duplicate key"
      error: "Raise error if duplicate keys found"

configuration_notes:
  stage_workflow: "This processor only works with stages - use import_file to load external files first"
  key_normalization: "Automatic normalization handles most real-world key matching issues"
  column_conflicts: "Use prefix/suffix when lookup columns have same names as existing columns"
  join_strategies: "Use 'inner' to filter invalid data, 'left' to enrich all data"
  performance: "For large datasets, ensure lookup stages are properly indexed"
  error_handling: "Clear error messages indicate missing stages, columns, or configuration issues"
