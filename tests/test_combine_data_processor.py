"""
Test module for enhanced CombineDataProcessor.

Tests the enhanced column handling, header retention, and smart defaults functionality.
"""

import os
import sys
import pandas as pd

# Add project root to Python path for imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from excel_recipe_processor.core.stage_manager import StageManager
from excel_recipe_processor.processors.base_processor import StepProcessorError
from excel_recipe_processor.processors.combine_data_processor import CombineDataProcessor


def create_title_section():
    """Create a title section with simple numeric columns."""
    return pd.DataFrame({
        0: ['Company Annual Report', 'Financial Year 2024', 'Executive Summary'],
        1: ['', 'Q1-Q4 Performance', 'Revenue Growth: 15%'],
        2: ['', 'Prepared by Finance Dept', 'Margin Improvement: 8%']
    })


def create_data_section():
    """Create a data section with named columns."""
    return pd.DataFrame({
        'Product': ['A001', 'A002', 'A003'],
        'Sales': [15000, 23000, 18500],
        'Region': ['North', 'South', 'East']
    })


def create_metadata_section():
    """Create metadata with different column structure."""
    return pd.DataFrame({
        'Field': ['Report Date', 'Generated By', 'Version'],
        'Value': ['2024-07-28', 'DataProcessor v2.1', '1.0']
    })


def test_configuration_validation():
    """Test enhanced configuration validation."""
    print("\nTesting enhanced configuration validation...")
    
    # Test 1: Missing required column_handling parameter
    try:
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'vertical_stack',
            'data_sources': [{'insert_from_stage': 'test_stage'}]
            # Missing column_handling
        }
        processor = CombineDataProcessor(step_config)
        processor.execute(None)
        print("✗ Should have failed with missing column_handling")
        return False
    except StepProcessorError as e:
        if "column_handling" in str(e):
            print("✓ Correctly caught missing column_handling")
        else:
            print(f"✗ Wrong error for missing column_handling: {e}")
            return False
    
    # Test 2: Invalid column_handling value
    try:
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'vertical_stack',
            'column_handling': 'invalid_policy',
            'data_sources': [{'insert_from_stage': 'test_stage'}]
        }
        processor = CombineDataProcessor(step_config)
        processor.execute(None)
        print("✗ Should have failed with invalid column_handling")
        return False
    except StepProcessorError as e:
        if "Invalid column_handling" in str(e):
            print("✓ Correctly caught invalid column_handling")
        else:
            print(f"✗ Wrong error for invalid column_handling: {e}")
            return False
    
    # Test 3: Invalid retain_column_names type
    try:
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'vertical_stack',
            'column_handling': 'allow_mismatched_columns',
            'data_sources': [
                {
                    'insert_from_stage': 'test_stage',
                    'retain_column_names': 'invalid'  # Should be boolean
                }
            ]
        }
        processor = CombineDataProcessor(step_config)
        processor.execute(None)
        print("✗ Should have failed with invalid retain_column_names type")
        return False
    except StepProcessorError as e:
        if "retain_column_names must be a boolean" in str(e):
            print("✓ Correctly caught invalid retain_column_names type")
        else:
            print(f"✗ Wrong error for invalid retain_column_names: {e}")
            return False
    
    print("✓ Enhanced configuration validation tests passed")
    return True


def test_require_matching_columns_policy():
    """Test require_matching_columns policy behavior."""
    print("\nTesting require_matching_columns policy...")
    
    StageManager.initialize_stages()
    
    try:
        # Create and save data with different column structures
        title_data = create_title_section()
        data_section = create_data_section()
        
        StageManager.save_stage('Report Title Section', title_data, description='Title section')
        StageManager.save_stage('Product Data Section', data_section, description='Data section')
        
        # Test with require_matching_columns - should fail
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'vertical_stack',
            'column_handling': 'require_matching_columns',
            'data_sources': [
                {'insert_from_stage': 'Report Title Section'},
                {'insert_from_stage': 'Product Data Section'}
            ]
        }
        
        processor = CombineDataProcessor(step_config)
        
        try:
            result = processor.execute(None)
            print("✗ Should have failed with column mismatch under require_matching_columns")
            return False
        except StepProcessorError as e:
            if "Column mismatch" in str(e) and "allow_mismatched_columns" in str(e):
                print("✓ Correctly caught column mismatch with require_matching_columns")
            else:
                print(f"✗ Wrong error for column mismatch: {e}")
                return False
        
        return True
        
    finally:
        StageManager.cleanup_stages()


def test_allow_mismatched_columns_policy():
    """Test allow_mismatched_columns policy behavior."""
    print("\nTesting allow_mismatched_columns policy...")
    
    StageManager.initialize_stages()
    
    try:
        # Create and save data with different column structures
        title_data = create_title_section()
        data_section = create_data_section()
        
        StageManager.save_stage('Report Title Section', title_data, description='Title section')
        StageManager.save_stage('Product Data Section', data_section, description='Data section')
        
        # Test with allow_mismatched_columns - should succeed
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'vertical_stack',
            'column_handling': 'allow_mismatched_columns',
            'data_sources': [
                {'insert_from_stage': 'Report Title Section'},
                {'insert_from_stage': 'Product Data Section'}
            ]
        }
        
        processor = CombineDataProcessor(step_config)
        result = processor.execute(None)
        
        # Should combine successfully with 6 columns (3 from title + 3 from data)
        expected_cols = 6  # Columns: [0, 1, 2, Product, Sales, Region]
        if len(result.columns) == expected_cols:
            print(f"✓ Successfully combined mismatched columns: {len(result.columns)} total columns")
        else:
            print(f"✗ Expected {expected_cols} columns, got {len(result.columns)}")
            print(f"Columns: {list(result.columns)}")
            return False
        
        # Should have 8 rows due to smart defaults adding headers
        # Expected: 1 title header + 3 title + 1 data header + 3 data = 8 rows
        if len(result) == 8:
            print(f"✓ Smart defaults correctly added headers: {len(result)} rows")
            return True
        else:
            print(f"✗ Expected 8 rows with smart defaults, got {len(result)}")
            print(f"Result:\n{result}")
            return False
        
    finally:
        StageManager.cleanup_stages()


def test_explicit_retain_column_names():
    """Test explicit retain_column_names setting."""
    print("\nTesting explicit retain_column_names setting...")
    
    StageManager.initialize_stages()
    
    try:
        # Create data sections
        data_section = create_data_section()
        metadata_section = create_metadata_section()
        
        StageManager.save_stage('Product Data Section', data_section, description='Data section')
        StageManager.save_stage('Report Metadata Section', metadata_section, description='Metadata section')
        
        # Test with explicit retain_column_names=True
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'vertical_stack',
            'column_handling': 'allow_mismatched_columns',  # Allow different structures
            'data_sources': [
                {
                    'insert_from_stage': 'Product Data Section',
                    'retain_column_names': True  # Explicit override
                },
                {'insert_blank_rows': 1},
                {
                    'insert_from_stage': 'Report Metadata Section',
                    'retain_column_names': False  # Explicit no header retention
                }
            ]
        }
        
        processor = CombineDataProcessor(step_config)
        result = processor.execute(None)
        
        # First row should be headers from Data section: ['Product', 'Sales', 'Region']
        first_row_values = result.iloc[0].tolist()
        if 'Product' in first_row_values and 'Sales' in first_row_values:
            print("✓ Headers correctly retained as first data row")
        else:
            print(f"✗ Headers not found in first row: {first_row_values}")
            return False
        
        # Should have: 1 header row + 3 data rows + 1 blank row + 3 metadata rows = 8 rows
        if len(result) == 8:
            print(f"✓ Correct total row count with header retention: {len(result)} rows")
            return True
        else:
            print(f"✗ Expected 8 rows, got {len(result)}")
            print(f"Result:\n{result}")
            return False
        
    finally:
        StageManager.cleanup_stages()


def test_smart_defaults_allow_mismatched():
    """Test smart defaults with allow_mismatched_columns policy."""
    print("\nTesting smart defaults with allow_mismatched_columns...")
    
    StageManager.initialize_stages()
    
    try:
        # Create data with different structures
        title_data = create_title_section()
        data_section = create_data_section()
        
        StageManager.save_stage('Report Title Section', title_data, description='Title section')
        StageManager.save_stage('Product Data Section', data_section, description='Data section')
        
        # With allow_mismatched_columns, retain_column_names should default to True
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'vertical_stack',
            'column_handling': 'allow_mismatched_columns',
            'data_sources': [
                {'insert_from_stage': 'Report Title Section'},  # No explicit retain_column_names
                {'insert_blank_rows': 1},
                {'insert_from_stage': 'Product Data Section'}   # No explicit retain_column_names
            ]
        }
        
        processor = CombineDataProcessor(step_config)
        result = processor.execute(None)
        
        # Should have headers inserted for both sections due to smart defaults
        # Expected: 1 title header + 3 title data + 1 blank + 1 data header + 3 data rows = 9 rows
        if len(result) == 9:
            print("✓ Smart defaults correctly applied headers to both sections")
        else:
            print(f"✗ Expected 9 rows with smart defaults, got {len(result)}")
            print(f"Result:\n{result}")
            return False
        
        # Check that first and sixth rows contain header information
        first_row = result.iloc[0].tolist()  # Title headers: [0, 1, 2]
        sixth_row = result.iloc[5].tolist()  # Data headers: ['Product', 'Sales', 'Region']
        
        # Title headers should contain numeric column names
        title_headers_found = any(str(val) in ['0', '1', '2'] for val in first_row if pd.notna(val))
        
        # Data headers should contain named columns
        data_headers_found = any(str(val) in ['Product', 'Sales', 'Region'] for val in sixth_row if pd.notna(val))
        
        if title_headers_found and data_headers_found:
            print("✓ Headers correctly preserved in both sections")
            return True
        else:
            print(f"✗ Headers not preserved correctly")
            print(f"First row (title headers): {first_row}")
            print(f"Sixth row (data headers): {sixth_row}")
            return False
        
    finally:
        StageManager.cleanup_stages()


def test_smart_defaults_require_matching():
    """Test smart defaults with require_matching_columns policy."""
    print("\nTesting smart defaults with require_matching_columns...")
    
    StageManager.initialize_stages()
    
    try:
        # Create data with same structure
        data1 = create_data_section()
        data2 = pd.DataFrame({
            'Product': ['B001', 'B002'],
            'Sales': [12000, 19000],
            'Region': ['West', 'Central']
        })
        
        StageManager.save_stage('Product Data Set 1', data1, description='First data section')
        StageManager.save_stage('Product Data Set 2', data2, description='Second data section')
        
        # With require_matching_columns, retain_column_names should default to False
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'vertical_stack',
            'column_handling': 'require_matching_columns',
            'data_sources': [
                {'insert_from_stage': 'Product Data Set 1'},  # No explicit retain_column_names
                {'insert_blank_rows': 1},
                {'insert_from_stage': 'Product Data Set 2'}   # No explicit retain_column_names
            ]
        }
        
        processor = CombineDataProcessor(step_config)
        result = processor.execute(None)
        
        # Should have no headers inserted due to smart defaults
        # Expected: 3 data1 rows + 1 blank + 2 data2 rows = 6 rows
        if len(result) == 6:
            print("✓ Smart defaults correctly omitted headers for matching columns")
        else:
            print(f"✗ Expected 6 rows with smart defaults, got {len(result)}")
            return False
        
        # First row should be actual data, not headers
        first_row_product = result.iloc[0]['Product']
        if first_row_product == 'A001':  # Actual data, not 'Product' header
            print("✓ No headers inserted with require_matching_columns smart default")
            return True
        else:
            print(f"✗ Expected data, got headers: {first_row_product}")
            return False
        
    finally:
        StageManager.cleanup_stages()


def test_desktop_publishing_workflow():
    """Test complete desktop publishing workflow combining title, headers, and data."""
    print("\nTesting desktop publishing workflow...")
    
    StageManager.initialize_stages()
    
    try:
        # Create realistic document sections
        title_section = pd.DataFrame({
            0: ['QUARTERLY SALES REPORT'],
            1: ['Q3 2024 Performance Summary'],
            2: ['Marketing Department']
        })
        
        header_section = pd.DataFrame({
            'Product_ID': ['Product ID'],
            'Product_Name': ['Product Name'],
            'Q3_Sales': ['Q3 Sales ($)'],
            'Growth_Rate': ['Growth Rate (%)']
        })
        
        data_section = pd.DataFrame({
            'Product_ID': ['PRD-001', 'PRD-002', 'PRD-003'],
            'Product_Name': ['Widget A', 'Widget B', 'Widget C'],
            'Q3_Sales': [125000, 98000, 156000],
            'Growth_Rate': [15.2, -2.1, 23.8]
        })
        
        footer_section = pd.DataFrame({
            'Note': ['* All figures in USD'],
            'Contact': ['Generated by: sales@company.com'],
            'Date': ['Report Date: 2024-07-28']
        })
        
        # Save all sections
        StageManager.save_stage('Report Title', title_section, description='Report title')
        StageManager.save_stage('Column Headers', header_section, description='Column headers')
        StageManager.save_stage('Sales Data', data_section, description='Sales data')
        StageManager.save_stage('Report Footer', footer_section, description='Report footer')
        
        # Combine with desktop publishing approach
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'vertical_stack',
            'column_handling': 'allow_mismatched_columns',  # Different section structures
            'data_sources': [
                {
                    'insert_from_stage': 'Report Title',
                    'retain_column_names': True  # Preserve title structure
                },
                {'insert_blank_rows': 2},  # Visual spacing
                {
                    'insert_from_stage': 'Column Headers',
                    'retain_column_names': False  # Headers will become data
                },
                {
                    'insert_from_stage': 'Sales Data',
                    'retain_column_names': False  # Pure data
                },
                {'insert_blank_rows': 1},  # Space before footer
                {
                    'insert_from_stage': 'Report Footer',
                    'retain_column_names': True  # Preserve footer structure
                }
            ]
        }
        
        processor = CombineDataProcessor(step_config)
        result = processor.execute(None)
        
        # Verify document structure
        # Expected: 1 title header + 1 title + 2 blank + 1 headers + 3 data + 1 blank + 1 footer header + 1 footer = 11 rows
        if len(result) == 11:
            print("✓ Desktop publishing document assembled correctly")
        else:
            print(f"✗ Expected 11 rows in final document, got {len(result)}")
            return False
        
        # Verify content preservation
        # Title should be in early rows
        title_found = any('QUARTERLY SALES REPORT' in str(val) for val in result.iloc[:3].values.flatten() if pd.notna(val))
        
        # Data should be in middle rows
        data_found = any('PRD-001' in str(val) for val in result.iloc[4:8].values.flatten() if pd.notna(val))
        
        # Footer should be in late rows
        footer_found = any('sales@company.com' in str(val) for val in result.iloc[8:].values.flatten() if pd.notna(val))
        
        if title_found and data_found and footer_found:
            print("✓ All document sections preserved with correct content")
            return True
        else:
            print("✗ Document content not preserved correctly")
            print(f"Title found: {title_found}, Data found: {data_found}, Footer found: {footer_found}")
            return False
        
    finally:
        StageManager.cleanup_stages()


def test_horizontal_with_header_retention():
    """Test horizontal concatenation with header retention."""
    print("\nTesting horizontal concatenation with header retention...")
    
    StageManager.initialize_stages()
    
    try:
        # Create data for side-by-side comparison
        current_year = pd.DataFrame({
            'Product': ['A001', 'A002', 'A003'],
            'Current_Sales': [15000, 23000, 18500]
        })
        
        previous_year = pd.DataFrame({
            'Product': ['A001', 'A002', 'A003'],
            'Previous_Sales': [12000, 21000, 16000]
        })
        
        StageManager.save_stage('Current Year Sales', current_year, description='Current year data')
        StageManager.save_stage('Previous Year Sales', previous_year, description='Previous year data')
        
        # Horizontal combination with header retention
        step_config = {
            'processor_type': 'combine_data',
            'combine_type': 'horizontal_concat',
            'column_handling': 'allow_mismatched_columns',
            'data_sources': [
                {
                    'insert_from_stage': 'Current Year Sales',
                    'retain_column_names': True
                },
                {'insert_blank_cols': 1},
                {
                    'insert_from_stage': 'Previous Year Sales',
                    'retain_column_names': True
                }
            ]
        }
        
        processor = CombineDataProcessor(step_config)
        result = processor.execute(None)
        
        # Should have headers + data rows: 1 header + 3 data = 4 rows
        if len(result) == 4:
            print("✓ Horizontal concatenation with headers completed correctly")
        else:
            print(f"✗ Expected 4 rows, got {len(result)}")
            return False
        
        # Should have columns from both sources plus blank column
        # Current (2) + Blank (1) + Previous (2) = 5 columns
        if len(result.columns) == 5:
            print(f"✓ Correct column count for horizontal combination: {len(result.columns)}")
            return True
        else:
            print(f"✗ Expected 5 columns, got {len(result.columns)}")
            print(f"Columns: {list(result.columns)}")
            return False
        
    finally:
        StageManager.cleanup_stages()


def test_capabilities():
    """Test enhanced processor capabilities reporting."""
    print("\nTesting enhanced capabilities...")
    
    step_config = {
        'processor_type': 'combine_data',
        'combine_type': 'vertical_stack',
        'column_handling': 'allow_mismatched_columns',
        'data_sources': [{'insert_from_stage': 'current_dataframe'}]
    }
    
    processor = CombineDataProcessor(step_config)
    capabilities = processor.get_capabilities()
    
    # Check for new capabilities
    required_keys = [
        'supported_column_policies',
        'column_policies',
        'smart_defaults'
    ]
    
    missing_keys = [key for key in required_keys if key not in capabilities]
    if missing_keys:
        print(f"✗ Missing capability keys: {missing_keys}")
        return False
    
    # Check column policies
    policies = processor.get_supported_column_policies()
    expected_policies = ['require_matching_columns', 'allow_mismatched_columns']
    if set(policies) == set(expected_policies):
        print("✓ Column policies reported correctly")
    else:
        print(f"✗ Wrong column policies: {policies}")
        return False
    
    # Check for desktop publishing in examples
    if 'desktop_publishing' in capabilities['examples']:
        print("✓ Desktop publishing example included")
        return True
    else:
        print("✗ Desktop publishing example missing")
        return False


if __name__ == '__main__':
    print("Testing Enhanced CombineDataProcessor...")
    success = True
    
    success &= test_configuration_validation()
    success &= test_require_matching_columns_policy()
    success &= test_allow_mismatched_columns_policy()
    success &= test_explicit_retain_column_names()
    success &= test_smart_defaults_allow_mismatched()
    success &= test_smart_defaults_require_matching()
    success &= test_desktop_publishing_workflow()
    success &= test_horizontal_with_header_retention()
    success &= test_capabilities()
    
    if success:
        print("\n🎉 All Enhanced CombineDataProcessor tests passed!")
    else:
        print("\n❌ Some Enhanced CombineDataProcessor tests failed!")
    
    print("\nTo run with pytest: pytest test_enhanced_combine_data_processor.py -v")
