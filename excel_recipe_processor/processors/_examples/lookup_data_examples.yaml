# Revision date: 2025-07-30

description: "Enrich data with VLOOKUP/XLOOKUP-equivalent operations from external sources using stage-based data flow"

basic_example:
  description: "Simple customer lookup with inline dictionary data"
  yaml: |
    # Enrich order data with customer information using dictionary lookup
    
    settings:
      description: "Add customer details to order data"
      stages:
        - stage_name: "order_data"
          description: "Raw order data"
          protected: false
        - stage_name: "enriched_orders"
          description: "Orders with customer details"
          protected: false
    
    recipe:
      # Previous steps populate order_data stage
      - step_description: "Add customer details to orders"
        # REQ - Must be "lookup_data" for this processor type
        processor_type: "lookup_data"
        # REQ - Stage to read data from
        source_stage: "order_data"
        # REQ - Stage to save enriched results
        save_to_stage: "enriched_orders"
        # REQ - Lookup data source configuration
        lookup_source:
          # REQ - Inline dictionary data type
          type: "inline"
          # REQ - Dictionary mapping lookup keys to data
          data:
            - Customer_ID: "CUST001"
              Customer_Name: "Acme Corp"
              Region: "West"
              Tier: "Premium"
            - Customer_ID: "CUST002"
              Customer_Name: "Beta Inc"
              Region: "East"
              Tier: "Standard"
        # REQ - Column in lookup data to match against
        match_col_in_lookup_data: "Customer_ID"
        # REQ - Column in main data to match with match_col_in_lookup_data
        match_col_in_main_data: "Customer_ID"
        # REQ - List of columns to retrieve from lookup data
        lookup_columns: ["Customer_Name", "Region", "Tier"]

excel_file_example:
  description: "Lookup from Excel file with sheet selection"
  yaml: |
    # Enrich product data with details from Excel reference file
    
    settings:
      description: "Add product catalog information to sales data"
      stages:
        - stage_name: "sales_data"
          description: "Raw sales transaction data"
          protected: false
        - stage_name: "product_enriched_sales"
          description: "Sales data with product details"
          protected: false
    
    recipe:
      - step_description: "Add product catalog details from Excel"
        processor_type: "lookup_data"
        source_stage: "sales_data"
        save_to_stage: "product_enriched_sales"
        # REQ - Excel file lookup source
        lookup_source:
          # REQ - File-based lookup type
          type: "file"
          # REQ - Path to Excel file (supports variable substitution)
          filename: "reference_data/product_catalog.xlsx"
          # OPT - Sheet name or 1-based index (converts to 0-based internally for pandas)
          # Default value: 1 (first sheet)
          sheet: "Products"
          # OPT - Text encoding (ignored for Excel files)
          # Default value: "utf-8"
          encoding: "utf-8"
        # REQ - Product key in lookup file
        match_col_in_lookup_data: "Product_SKU"
        # REQ - Product key in main data
        match_col_in_main_data: "SKU"
        # REQ - Product information to add
        lookup_columns: ["Product_Name", "Category", "Unit_Cost", "Supplier"]
        # OPT - Join type for lookup operation
        # Valid values: "left", "right", "inner", "outer"
        # Default value: "left"
        join_type: "left"
        # OPT - Default values for non-matches
        default_values:
          "Product_Name": "Unknown Product"
          "Category": "Uncategorized"
          "Unit_Cost": 0.0

csv_lookup_example:
  description: "Lookup from CSV file with custom encoding"
  yaml: |
    # Enrich customer data with regional territory information
    
    settings:
      description: "Add sales territory data from CSV reference"
      variables:
        territory_year: "2024"
      stages:
        - stage_name: "customer_data"
          description: "Customer base data"
          protected: false
        - stage_name: "territory_assigned_customers"
          description: "Customers with territory assignments"
          protected: false
    
    recipe:
      - step_description: "Add territory assignments from CSV"
        processor_type: "lookup_data"
        source_stage: "customer_data"
        save_to_stage: "territory_assigned_customers"
        # REQ - CSV file lookup source
        lookup_source:
          type: "file"
          # REQ - CSV file path with variable substitution
          filename: "territories/sales_territories_{territory_year}.csv"
          # OPT - Text encoding for CSV files
          # Default value: "utf-8"
          encoding: "utf-8"
          # OPT - Field separator for CSV files
          # Default value: ","
          separator: ","
        # REQ - Territory key in CSV file
        match_col_in_lookup_data: "Territory_Code"
        # REQ - Territory key in customer data
        match_col_in_main_data: "Territory"
        # REQ - Territory information to add
        lookup_columns: ["Territory_Manager", "Commission_Rate", "Tax_Rate"]
        # OPT - Case sensitivity for key matching
        # Default value: true
        case_sensitive: false

stage_lookup_example:
  description: "Lookup from previously saved stage data"
  yaml: |
    # Use customer segmentation results to enrich order data
    
    settings:
      description: "Combine order data with customer segmentation results"
      stages:
        - stage_name: "order_transactions"
          description: "Transaction order data"
          protected: false
        - stage_name: "customer_segments"
          description: "Customer segmentation analysis results"
          protected: false
        - stage_name: "segmented_orders"
          description: "Orders enriched with customer segments"
          protected: false
    
    recipe:
      # Previous steps would populate both order_transactions and customer_segments
      - step_description: "Add customer segmentation to orders"
        processor_type: "lookup_data"
        source_stage: "order_transactions"
        save_to_stage: "segmented_orders"
        # REQ - Stage-based lookup source
        lookup_source:
          # REQ - Source type specification
          type: "stage"
          # REQ - Name of previously saved stage
          # Must match exactly what was saved with previous save_to_stage directive
          stage_name: "customer_segments"
        # REQ - Key column in the saved stage data
        match_col_in_lookup_data: "Customer_ID"
        # REQ - Key column in current pipeline data
        match_col_in_main_data: "Customer_ID"
        # REQ - Segmentation data to add
        lookup_columns: ["Customer_Segment", "Lifetime_Value", "Risk_Score", "Next_Best_Action"]
        # OPT - Inner join to only keep customers that went through segmentation
        # Default value: "left"
        join_type: "inner"

case_insensitive_example:
  description: "Handle inconsistent case in lookup keys"
  yaml: |
    # Flexible matching for data with inconsistent capitalization
    
    settings:
      description: "Match customers despite case differences in identifiers"
      stages:
        - stage_name: "mixed_case_data"
          description: "Data with inconsistent case formatting"
          protected: false
        - stage_name: "standardized_data"
          description: "Data with matched customer information"
          protected: false
    
    recipe:
      - step_description: "Match customers despite case differences"
        processor_type: "lookup_data"
        source_stage: "mixed_case_data"
        save_to_stage: "standardized_data"
        # REQ - Customer reference file
        lookup_source:
          type: "file"
          filename: "customer_reference.xlsx"
          sheet: "Active_Customers"
        # REQ - Key column in reference file
        match_col_in_lookup_data: "Customer_Code"
        # REQ - Key column in main data (may have different case)
        match_col_in_main_data: "Cust_Code"
        # REQ - Customer details to retrieve
        lookup_columns: ["Customer_Name", "Account_Manager", "Credit_Limit"]
        # REQ - Enable case-insensitive matching
        # Matches: "CUST001" = "cust001" = "Cust001"
        # Default value: true
        case_sensitive: false
        # OPT - Handle missing matches
        default_values:
          "Customer_Name": "Name Not Found"
          "Account_Manager": "TBD"
          "Credit_Limit": 0

duplicate_handling_example:
  description: "Control how duplicate lookup keys are handled"
  yaml: |
    # Manage lookup data with duplicate keys effectively
    
    settings:
      description: "Handle product pricing with potential duplicate entries"
      stages:
        - stage_name: "order_items"
          description: "Order line items needing pricing"
          protected: false
        - stage_name: "priced_items"
          description: "Order items with current pricing"
          protected: false
    
    recipe:
      - step_description: "Add latest product pricing with duplicate handling"
        processor_type: "lookup_data"
        source_stage: "order_items"
        save_to_stage: "priced_items"
        # REQ - Price list file (may have multiple entries per product)
        lookup_source:
          type: "file"
          filename: "price_lists/current_pricing.csv"
        # REQ - Product key in price list
        match_col_in_lookup_data: "Product_SKU"
        # REQ - Product key in main data
        match_col_in_main_data: "SKU"
        # REQ - Pricing information to add
        lookup_columns: ["Current_Price", "Effective_Date", "Price_Tier"]
        # REQ - Duplicate handling strategy
        # "first": use first occurrence of duplicate key
        # "last": use last occurrence of duplicate key (latest update)
        # "error": stop processing if duplicates found
        # Default value: "first"
        handle_duplicates: "last"

column_naming_example:
  description: "Add prefixes and suffixes to lookup columns"
  yaml: |
    # Customize lookup column names to avoid conflicts
    
    settings:
      description: "Add customer reference data with prefixed names"
      stages:
        - stage_name: "base_data"
          description: "Base data with potential column conflicts"
          protected: false
        - stage_name: "prefixed_data"
          description: "Data with clearly named lookup columns"
          protected: false
    
    recipe:
      - step_description: "Add customer reference data with prefixed names"
        processor_type: "lookup_data"
        source_stage: "base_data"
        save_to_stage: "prefixed_data"
        # REQ - Customer master data
        lookup_source:
          type: "file"
          filename: "customer_master.xlsx"
        # REQ - Customer key in lookup data
        match_col_in_lookup_data: "Customer_ID"
        # REQ - Customer key in main data
        match_col_in_main_data: "Customer_ID"
        # REQ - Customer details to retrieve
        lookup_columns: ["Name", "Type", "Status", "Region"]
        # OPT - Prefix to add to all lookup column names
        # Result: "Customer_Name", "Customer_Type", "Customer_Status", "Customer_Region"
        # Default value: ""
        prefix: "Customer_"
        # OPT - Suffix to add to all lookup column names
        # Combined with prefix: "Customer_Name_Ref", "Customer_Type_Ref", etc.
        # Default value: ""
        suffix: "_Ref"

parameter_details:
  lookup_source:
    type: dict_or_string
    required: true
    description: "Configuration for the lookup data source"
    formats: ["file path string", "configuration dictionary"]
    examples: ["customers.xlsx", "{'type': 'stage', 'stage_name': 'Customer_Data'}", "{'CA': {'Region': 'West'}}"]
  
  match_col_in_lookup_data:
    type: string_or_list
    required: true
    description: "Column name(s) in lookup data to match against - can be single column or list for composite keys"
    examples: ["Customer_ID", "Product_SKU", ["Product_Code", "Region"]]
  
  match_col_in_main_data:
    type: string_or_list
    required: true
    description: "Column name(s) in main data to match with match_col_in_lookup_data - must match structure of match_col_in_lookup_data"
    examples: ["Cust_ID", "SKU", ["Product", "Sales_Region"]]
  
  lookup_columns:
    type: list
    required: true
    description: "List of columns to retrieve from lookup data and add to main data"
    examples: [["Customer_Name", "Region"], ["Price", "Category", "Supplier"]]
  
  lookup_sheet:
    type: string_or_int
    required: false
    # Uses 1-based indexing, converts to 0-based internally for pandas
    default: "1"
    context: "Used when lookup_source is an Excel file"
    description: "Sheet name or index to read from Excel file"
    examples: ["Customer_Master", "Products", 1, 2]
  
  join_type:
    type: string
    required: false
    default: "left"
    description: "Type of join operation to perform between main data and lookup data"
    valid_values: ["left", "right", "inner", "outer"]
    details:
      left: "Keep all main data rows, add lookup data where available"
      right: "Keep all lookup data rows, add main data where available"
      inner: "Only keep rows that have matches in both datasets"
      outer: "Keep all rows from both main data and lookup data"
  
  handle_duplicates:
    type: string
    required: false
    default: "first"
    description: "Strategy for handling duplicate keys in lookup data"
    valid_values: ["first", "last", "error"]
    details:
      first: "Use first occurrence of duplicate key"
      last: "Use last occurrence of duplicate key"
      error: "Stop processing if duplicate keys are found"
  
  case_sensitive:
    type: boolean
    required: false
    default: true
    description: "Whether key matching should be case sensitive"
    examples: ["true: 'CUST001' != 'cust001'", "false: 'CUST001' == 'cust001'"]
  
  default_values:
    type: dict
    required: false
    description: "Dictionary of default values to use when lookup doesn't find a match"
    structure: "Keys are column names from lookup_columns, values are defaults"
    examples: ["{'Customer_Name': 'Unknown', 'Region': 'Unassigned'}"]
  
  prefix:
    type: string
    required: false
    default: ""
    description: "Prefix to add to all lookup column names to avoid conflicts"
    examples: ["Customer_", "Ref_", "Lookup_"]
  
  suffix:
    type: string
    required: false
    default: ""
    description: "Suffix to add to all lookup column names to avoid conflicts"
    examples: ["_Ref", "_Info", "_Data"]
  
  encoding:
    type: string
    required: false
    default: "utf-8"
    context: "Used when lookup_source is a CSV/TSV file"
    description: "Text encoding for CSV files - ignored for Excel files"
    examples: ["utf-8", "latin1", "cp1252"]

lookup_source_types:
  file:
    description: "External file (Excel, CSV, TSV) with optional sheet/encoding options"
    required_fields: ["filename"]
    optional_fields: ["sheet", "encoding", "separator"]
    best_for: "Reference data stored in files"
  
  stage:
    description: "Previously saved processing stage data"
    required_fields: ["stage_name"]
    best_for: "Multi-step processing workflows, intermediate results"
  
  inline:
    description: "Inline list of dictionaries for small lookup tables"
    required_fields: ["data"]
    best_for: "Small reference data, configuration mappings"

integration_notes:
  stage_manager: "All lookup operations work with declared stages - requires source_stage and save_to_stage"
  file_reader: "Uses FileReader infrastructure for consistent file handling"
  variable_substitution: "File paths and all parameters support variable substitution"
  vlookup_equivalent: "Provides VLOOKUP/XLOOKUP functionality with more flexibility"
  memory_efficiency: "Lookup results create new stage copy - original stage remains unchanged"
  stage_validation: "Both source_stage and save_to_stage must be declared in settings.stages"

common_use_cases:
  customer_enrichment: "Add customer details (name, region, tier) to transaction data"
  product_lookup: "Enrich orders with product information (name, category, price)"
  territory_assignment: "Map geographic data to sales territories and managers"
  reference_data_join: "Add lookup values from master data files"
  data_validation: "Use inner joins to filter for valid reference keys only"
  multi_source_enrichment: "Chain multiple lookups to build comprehensive datasets"
