# Usage Examples for slice_data processor
# Shows how to extract portions of DataFrames with 1-based indexing

description: |
  The slice_data processor extracts portions of DataFrames using user-friendly 1-based indexing.
  Perfect for separating metadata, headers, and data sections in complex Excel files.

basic_row_slicing_example:
  description: "Extract specific rows from a DataFrame"
  yaml: |
    # Extract metadata rows from top of Excel file
    
    - # OPT - Step description
      step_description: "Extract file metadata"
      # REQ - Processor type
      processor_type: "slice_data"
      # REQ - Type of slice operation
      slice_type: "row_range"
      # REQ - Starting row (1-based, matches Excel)
      start_row: 1
      # OPT - Ending row (1-based, inclusive)
      end_row: 3
      # OPT - Save result to stage for later use
      save_to_stage: "File Metadata"

data_extraction_with_headers_example:
  description: "Extract data section and promote headers"
  yaml: |
    # Extract data starting from where headers are located
    
    - # OPT - Step description  
      step_description: "Extract data with header promotion"
      # REQ - Processor type
      processor_type: "slice_data"
      # REQ - Type of slice operation
      slice_type: "row_range"
      # REQ - Row where data section starts (1-based)
      start_row: 4
      # OPT - End row (omit to get all remaining rows)
      # end_row: 10
      # OPT - First row of slice contains headers (default: false)
      slice_result_contains_headers: true
      # OPT - Save clean data to stage
      save_to_stage: "Clean Data"

column_slicing_example:
  description: "Extract specific columns by range"
  yaml: |
    # Extract columns using different reference methods
    
    - # OPT - Step description
      step_description: "Extract key columns"
      # REQ - Processor type
      processor_type: "slice_data"
      # REQ - Type of slice operation
      slice_type: "column_range"
      # REQ - Starting column (Excel reference)
      start_col: "A"
      # OPT - Ending column (Excel reference)
      end_col: "D"
      
    # Alternative: using 1-based column numbers
    - step_description: "Extract first 3 columns by number"
      processor_type: "slice_data"
      slice_type: "column_range"
      start_col: 1        # First column
      end_col: 3          # Third column
      
    # Alternative: using column names
    - step_description: "Extract by column names"
      processor_type: "slice_data"
      slice_type: "column_range"
      start_col: "Product ID"
      end_col: "Price"

stage_source_example:
  description: "Load data from stage instead of input stream"
  yaml: |
    # Process data from a previously saved stage
    
    - # OPT - Step description
      step_description: "Extract metadata from saved file"
      # REQ - Processor type
      processor_type: "slice_data"
      # REQ - Type of slice operation
      slice_type: "row_range"
      # REQ - Load data from this stage instead of input
      source_stage: "Raw File Data"
      # REQ - Starting row to extract
      start_row: 1
      # OPT - Ending row to extract
      end_row: 2
      # OPT - Save result to new stage
      save_to_stage: "File Headers"

automatic_header_detection_example:
  description: "Automatically find and extract data section"
  yaml: |
    # Let the processor find where real data starts
    
    - # OPT - Step description
      step_description: "Auto-detect data section"
      # REQ - Processor type
      processor_type: "slice_data"
      # REQ - Type of slice operation
      slice_type: "header_detection"
      # OPT - Maximum rows to scan for headers
      max_scan_rows: 20
      # OPT - Minimum non-empty columns to consider a header row (1 = any data)
      min_non_empty_cols: 1
      # OPT - Save detected data
      save_to_stage: "Detected Data"

complex_workflow_example:
  description: "Complete workflow separating metadata and data"
  yaml: |
    # Real-world example: process Excel file with metadata
    
    # Step 1: Import entire file without trying to interpret structure
    - step_description: "Import raw file"
      processor_type: "import_file"
      input_file: "monthly_report.xlsx"
      reading_options:
        header: null  # Don't try to detect headers yet
      save_to_stage: "Raw File"
    
    # Step 2: Extract metadata section
    - step_description: "Extract report metadata"
      processor_type: "slice_data"
      slice_type: "row_range"
      source_stage: "Raw File"
      start_row: 1
      end_row: 3
      save_to_stage: "Report Metadata"
    
    # Step 3: Extract data section with headers
    - step_description: "Extract data with headers"
      processor_type: "slice_data"
      slice_type: "row_range"
      source_stage: "Raw File"
      start_row: 5      # Skip blank row 4
      slice_result_contains_headers: true  # First row becomes headers
      save_to_stage: "Raw Data"
    
    # Step 4: Process the data normally
    - step_description: "Load clean data for processing"
      processor_type: "load_stage"
      stage_name: "Raw Data"
    
    - step_description: "Filter active records"
      processor_type: "filter_data"
      filters:
        - column: "Status"
          condition: "equals"
          value: "Active"
      save_to_stage: "Processed Data"
    
    # Step 5: Later, combine metadata + processed data for export
    # (This would use a future combine_data processor)

parameter_details:
  slice_type:
    type: string
    required: true
    description: "Type of slicing operation to perform"
    values: ["row_range", "column_range", "header_detection"]
  
  start_row:
    type: integer
    required: "for row_range slice_type"
    description: "Starting row number (1-based, matches Excel row numbers)"
    minimum: 1
    examples: [1, 4, 10]
  
  end_row:
    type: integer
    required: false
    description: "Ending row number (1-based, inclusive). Omit to slice to end"
    minimum: "must be >= start_row"
    examples: [3, 15, 100]
  
  start_col:
    type: "string or integer"
    required: "for column_range slice_type"
    description: "Starting column (Excel ref like 'A', 1-based number, or column name)"
    examples: ["A", "BH", 1, 5, "Product ID", "Total Sales"]
  
  end_col:
    type: "string or integer"
    required: false
    description: "Ending column (Excel ref, 1-based number, or name). Omit to slice to end"
    examples: ["D", "ZZ", 10, "Price", "Final Total"]
  
  slice_result_contains_headers:
    type: boolean
    required: false
    description: "Whether the first row of the slice contains column headers (default: false)"
    default: false
    examples: [true, false]
  
  source_stage:
    type: string
    required: false
    description: "Stage name to load data from instead of using input data"
    examples: ["Raw File", "Imported Data", "Previous Results"]

indexing_note: |
  IMPORTANT: All row and column numbers use 1-based indexing to match what users 
  see in Excel. Row 1 is the first row, Column A is column 1, etc. The processor 
  handles conversion to 0-based indexing internally.

common_patterns:
  - name: "Extract metadata"
    description: "Get title, date, and other metadata from top of file"
    config: "slice_type: row_range, start_row: 1, end_row: 3"
  
  - name: "Extract data section"
    description: "Get actual data starting from specific row with headers"
    config: "slice_type: row_range, start_row: 5, slice_result_contains_headers: true"
  
  - name: "Extract key columns"
    description: "Get only important columns from wide datasets"
    config: "slice_type: column_range, start_col: A, end_col: F"
